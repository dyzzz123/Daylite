import Parser from 'rss-parser';
import type { FeedItem } from '@/types';

// 创建多个parser配置，尝试不同的headers
const parsers = [
  new Parser({
    timeout: 15000,
    headers: {
      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      'Accept': 'application/rss+xml, application/xml, text/xml, */*',
    },
  }),
  new Parser({
    timeout: 15000,
    headers: {
      'User-Agent': 'FeedBot/1.0 (+https://example.com/bot)',
      'Accept': '*/*',
    },
  }),
  new Parser({
    timeout: 15000,
    headers: {
      'User-Agent': 'Mozilla/5.0 (compatible; RSSReader/1.0)',
    },
  }),
];

// 使用第一个parser作为默认
const parser = parsers[0];

export interface RSSFetcherConfig {
  url: string;
  sourceName: string;
  icon?: string;
}

// Fetch RSS feed and convert to FeedItem format
export async function fetchRSS(config: RSSFetcherConfig): Promise<FeedItem[]> {
  let lastError: Error | null = null;

  // 尝试使用不同的parser配置
  for (let i = 0; i < parsers.length; i++) {
    try {
      console.log(`[RSS Fetcher] 尝试使用配置 ${i + 1}/${parsers.length} 获取 ${config.url}`);
      const feed = await parsers[i].parseURL(config.url);

      const items: FeedItem[] = [];

      for (const item of feed.items) {
        if (!item.title) continue;

        // Extract publish date
        let publishTime = new Date();
        if (item.pubDate) {
          publishTime = new Date(item.pubDate);
        } else if (item.isoDate) {
          publishTime = new Date(item.isoDate);
        }

        // Extract summary
        let summary = '';
        if (item.contentSnippet) {
          summary = item.contentSnippet.substring(0, 300);
        } else if (item.content) {
          // Strip HTML tags and get first 300 chars
          summary = item.content.replace(/<[^>]*>/g, '').substring(0, 300);
        } else if (item.summary) {
          summary = item.summary.substring(0, 300);
        }

        // Extract tags/categories
        const tags: string[] = [];
        if (item.categories) {
          tags.push(...item.categories);
        }

        items.push({
          id: '', // Will be generated by feed-service
          source: 'rss',
          sourceName: config.sourceName,
          title: item.title,
          summary: summary || item.title,
          url: item.link,
          publishTime,
          read: false,
          tags: tags.length > 0 ? tags : undefined,
          createdAt: new Date(),
        });
      }

      console.log(`[RSS Fetcher] 成功使用配置 ${i + 1} 获取 ${items.length} 篇文章`);
      return items;
    } catch (error) {
      lastError = error as Error;
      console.error(`[RSS Fetcher] 配置 ${i + 1} 失败:`, (error as Error).message);

      // 如果不是最后一次尝试，继续尝试下一个配置
      if (i < parsers.length - 1) {
        continue;
      }
    }
  }

  console.error(`[RSS Fetcher] 所有配置均失败，无法获取 ${config.url}:`, lastError?.message);
  return [];
}

// Fetch multiple RSS feeds
export async function fetchMultipleRSS(configs: RSSFetcherConfig[]): Promise<FeedItem[]> {
  const results = await Promise.allSettled(configs.map((config) => fetchRSS(config)));

  const allItems: FeedItem[] = [];
  for (const result of results) {
    if (result.status === 'fulfilled') {
      allItems.push(...result.value);
    }
  }

  return allItems;
}

// Validate RSS feed URL with detailed error info
export async function validateRSSUrl(url: string): Promise<{ valid: boolean; error?: string }> {
  let lastError: Error | null = null;

  for (let i = 0; i < parsers.length; i++) {
    try {
      await parsers[i].parseURL(url);
      console.log(`[RSS Validator] 使用配置 ${i + 1} 验证成功: ${url}`);
      return { valid: true };
    } catch (error) {
      lastError = error as Error;
      console.error(`[RSS Validator] 配置 ${i + 1} 失败:`, (error as Error).message);

      if (i < parsers.length - 1) {
        continue;
      }
    }
  }

  // 返回详细的错误信息
  const errorMsg = lastError?.message || '未知错误';
  console.error(`[RSS Validator] 验证失败 ${url}:`, errorMsg);

  // 根据错误类型返回更友好的提示
  if (errorMsg.includes('ETIMEDOUT') || errorMsg.includes('timeout')) {
    return { valid: false, error: '连接超时，请检查网络或稍后重试' };
  } else if (errorMsg.includes('ENOTFOUND') || errorMsg.includes('getaddrinfo')) {
    return { valid: false, error: '无法解析域名，请检查URL是否正确' };
  } else if (errorMsg.includes('ECONNREFUSED')) {
    return { valid: false, error: '连接被拒绝，该服务器可能暂时不可用' };
  } else if (errorMsg.includes('404') || errorMsg.includes('Not Found')) {
    return { valid: false, error: 'RSS源不存在(404)，请检查URL' };
  } else if (errorMsg.includes('403') || errorMsg.includes('Forbidden')) {
    return { valid: false, error: '访问被拒绝，该RSS源可能限制了访问' };
  } else if (errorMsg.includes('parse') || errorMsg.includes('XML')) {
    return { valid: false, error: 'RSS格式错误，无法解析内容' };
  }

  return { valid: false, error: `无法解析RSS源: ${errorMsg}` };
}

// Get RSS feed metadata with retry
export async function getRSSMetadata(url: string): Promise<{
  title?: string;
  description?: string;
  link?: string;
} | null> {
  let lastError: Error | null = null;

  for (let i = 0; i < parsers.length; i++) {
    try {
      const feed = await parsers[i].parseURL(url);
      console.log(`[RSS Metadata] 使用配置 ${i + 1} 获取元数据成功: ${feed.title}`);
      return {
        title: feed.title,
        description: feed.description,
        link: feed.link,
      };
    } catch (error) {
      lastError = error as Error;
      if (i < parsers.length - 1) {
        continue;
      }
    }
  }

  console.error(`[RSS Metadata] 获取元数据失败:`, lastError?.message);
  return null;
}
