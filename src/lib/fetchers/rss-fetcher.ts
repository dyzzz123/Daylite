import Parser from 'rss-parser';
import type { FeedItem } from '@/types';
import { getFaviconUrl } from '@/lib/favicon-fetcher';

// Parser 配置：渐进式超时 + 不同 User-Agent
const parserConfigs = [
  {
    timeout: 20000, // 20秒
    headers: {
      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      'Accept': 'application/rss+xml, application/xml, text/xml, */*',
      'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
    } as Record<string, string>,
    name: 'Chrome'
  },
  {
    timeout: 30000, // 30秒
    headers: {
      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
      'Accept': 'application/rss+xml, application/xml, text/xml, */*',
      'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
    } as Record<string, string>,
    name: 'Firefox'
  },
  {
    timeout: 45000, // 45秒 - 给慢速源更多时间
    headers: {
      'User-Agent': 'FeedBot/1.0 (+https://feedbot.com)',
      'Accept': '*/*',
    } as Record<string, string>,
    name: 'FeedBot'
  },
  {
    timeout: 60000, // 60秒 - 最后尝试，最长等待
    headers: {
      'User-Agent': 'Mozilla/5.0 (compatible; RSSReader/1.0; +https://rssreader.com)',
      'Accept': 'application/rss+xml, application/xml, text/xml, */*',
    } as Record<string, string>,
    name: 'RSSReader'
  },
];

export interface RSSFetcherConfig {
  url: string;
  sourceName: string;
  icon?: string;
  faviconUrl?: string;  // 源已保存的 favicon
}

// 创建 parser（按需创建，避免重复创建）
function createParser(timeout: number, headers: Record<string, string>) {
  return new Parser({
    timeout,
    headers,
  });
}

// Fetch RSS feed and convert to FeedItem format
export async function fetchRSS(config: RSSFetcherConfig): Promise<FeedItem[]> {
  let lastError: Error | null = null;
  let lastParserName = '';

  // 尝试使用不同的parser配置（渐进式超时）
  for (let i = 0; i < parserConfigs.length; i++) {
    try {
      const { timeout, headers, name } = parserConfigs[i];
      const parser = createParser(timeout, headers);

      console.log(`[RSS Fetcher] 尝试配置 ${i + 1}/${parserConfigs.length} (${name}, ${timeout/1000}s): ${config.url}`);

      const feed = await parser.parseURL(config.url);

      // 使用传入的 faviconUrl，如果没有则尝试获取
      let faviconUrl: string | undefined = config.faviconUrl;
      if (!faviconUrl) {
        try {
          faviconUrl = await getFaviconUrl(config.url) || undefined;
          console.log(`[RSS Fetcher] 获取到 favicon: ${faviconUrl}`);
        } catch (error) {
          console.log(`[RSS Fetcher] 无法获取 favicon，跳过`);
        }
      } else {
        console.log(`[RSS Fetcher] 使用已保存的 favicon: ${faviconUrl}`);
      }

      const items: FeedItem[] = [];

      for (const item of feed.items) {
        if (!item.title) continue;

        // Extract publish date
        let publishTime = new Date();
        if (item.pubDate) {
          publishTime = new Date(item.pubDate);
        } else if (item.isoDate) {
          publishTime = new Date(item.isoDate);
        }

        // Extract summary
        let summary = '';
        if (item.contentSnippet) {
          summary = item.contentSnippet.substring(0, 300);
        } else if (item.content) {
          // Strip HTML tags and get first 300 chars
          summary = item.content.replace(/<[^>]*>/g, '').substring(0, 300);
        } else if (item.summary) {
          summary = item.summary.substring(0, 300);
        }

        // Extract tags/categories
        const tags: string[] = [];
        if (item.categories) {
          tags.push(...item.categories);
        }

        items.push({
          id: '', // Will be generated by feed-service
          source: 'rss',
          sourceName: config.sourceName,
          title: item.title,
          summary: summary || item.title,
          url: item.link,
          faviconUrl,
          publishTime,
          read: false,
          tags: tags.length > 0 ? tags : undefined,
          createdAt: new Date(),
        });
      }

      console.log(`[RSS Fetcher] ✓ 成功 (${name}): ${items.length} 篇文章`);
      return items;
    } catch (error) {
      lastError = error as Error;
      lastParserName = parserConfigs[i].name;

      const errorMsg = (error as Error).message;
      console.error(`[RSS Fetcher] ✗ 配置 ${i + 1} 失败 (${lastParserName}):`, errorMsg);

      // 如果是最后一次尝试，抛出错误
      if (i === parserConfigs.length - 1) {
        break;
      }

      // 否则继续尝试下一个配置
      console.log(`[RSS Fetcher] → 切换到下一个配置...`);
    }
  }

  console.error(`[RSS Fetcher] ✗ 所有配置均失败: ${config.url}`);
  return [];
}

// Fetch multiple RSS feeds
export async function fetchMultipleRSS(configs: RSSFetcherConfig[]): Promise<FeedItem[]> {
  const results = await Promise.allSettled(configs.map((config) => fetchRSS(config)));

  const allItems: FeedItem[] = [];
  for (const result of results) {
    if (result.status === 'fulfilled') {
      allItems.push(...result.value);
    }
  }

  return allItems;
}

// Validate RSS feed URL with detailed error info
export async function validateRSSUrl(url: string): Promise<{ valid: boolean; error?: string }> {
  let lastError: Error | null = null;
  let lastParserName = '';

  for (let i = 0; i < parserConfigs.length; i++) {
    try {
      const { timeout, headers, name } = parserConfigs[i];
      const parser = createParser(timeout, headers);

      console.log(`[RSS Validator] 尝试配置 ${i + 1}/${parserConfigs.length} (${name}, ${timeout/1000}s): ${url}`);

      await parser.parseURL(url);
      console.log(`[RSS Validator] ✓ 验证成功 (${name}): ${url}`);
      return { valid: true };
    } catch (error) {
      lastError = error as Error;
      lastParserName = parserConfigs[i].name;

      const errorMsg = (error as Error).message;
      console.error(`[RSS Validator] ✗ 配置 ${i + 1} 失败 (${lastParserName}):`, errorMsg);

      if (i < parserConfigs.length - 1) {
        console.log(`[RSS Validator] → 切换到下一个配置...`);
        continue;
      }
    }
  }

  // 返回详细的错误信息
  const errorMsg = lastError?.message || '未知错误';
  console.error(`[RSS Validator] ✗ 验证失败 (${lastParserName}): ${url}`);

  // 根据错误类型返回更友好的提示
  if (errorMsg.includes('ETIMEDOUT') || errorMsg.includes('timeout')) {
    return { valid: false, error: '连接超时，请稍后重试' };
  } else if (errorMsg.includes('ENOTFOUND') || errorMsg.includes('getaddrinfo')) {
    return { valid: false, error: '无法解析域名，请检查URL' };
  } else if (errorMsg.includes('ECONNREFUSED')) {
    return { valid: false, error: '连接被拒绝，服务器可能暂时不可用' };
  } else if (errorMsg.includes('404') || errorMsg.includes('Not Found')) {
    return { valid: false, error: 'RSS源不存在(404)' };
  } else if (errorMsg.includes('403') || errorMsg.includes('Forbidden')) {
    return { valid: false, error: '访问被拒绝，该RSS源限制了访问' };
  } else if (errorMsg.includes('parse') || errorMsg.includes('XML')) {
    return { valid: false, error: 'RSS格式错误' };
  }

  return { valid: false, error: `无法解析RSS源` };
}

// Get RSS feed metadata with retry
export async function getRSSMetadata(url: string): Promise<{
  title?: string;
  description?: string;
  link?: string;
} | null> {
  let lastError: Error | null = null;

  for (let i = 0; i < parserConfigs.length; i++) {
    try {
      const { timeout, headers, name } = parserConfigs[i];
      const parser = createParser(timeout, headers);

      const feed = await parser.parseURL(url);
      console.log(`[RSS Metadata] ✓ 成功 (${name}): ${feed.title}`);
      return {
        title: feed.title,
        description: feed.description,
        link: feed.link,
      };
    } catch (error) {
      lastError = error as Error;
      if (i < parserConfigs.length - 1) {
        continue;
      }
    }
  }

  console.error(`[RSS Metadata] ✗ 获取元数据失败:`, lastError?.message);
  return null;
}
